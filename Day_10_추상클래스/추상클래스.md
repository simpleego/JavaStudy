# 추상 클래스로 확장한 상속 예제

## 예제 1: 동물 추상 클래스로 확장

```java
// 추상 부모 클래스
abstract class Animal {
    private String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    // 추상 메소드 - 자식 클래스에서 반드시 구현해야 함
    public abstract void makeSound();
    
    // 일반 메소드 - 자식 클래스에서 공통으로 사용
    public void eat() {
        System.out.println(name + "이(가) 먹이를 먹습니다.");
    }
    
    public void sleep() {
        System.out.println(name + "이(가) 잠을 잡니다.");
    }
    
    public String getName() {
        return name;
    }
    
    // 템플릿 메소드 패턴 예시
    public final void dailyRoutine() {
        System.out.println("=== " + name + "의 하루 일과 ===");
        wakeUp();
        eat();
        makeSound();
        sleep();
        System.out.println();
    }
    
    // 추상 메소드 (선택적)
    protected abstract void wakeUp();
}

// 자식 클래스 1
class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }
    
    @Override
    public void makeSound() {
        System.out.println(getName() + ": 왈왈!");
    }
    
    @Override
    protected void wakeUp() {
        System.out.println(getName() + "이(가) 활기차게 일어났습니다!");
    }
    
    @Override
    public void eat() {
        System.out.println(getName() + "이(가) 사료를 맛있게 먹습니다.");
    }
}

// 자식 클래스 2
class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }
    
    @Override
    public void makeSound() {
        System.out.println(getName() + ": 야옹~");
    }
    
    @Override
    protected void wakeUp() {
        System.out.println(getName() + "이(가) 느릿하게 일어났습니다.");
    }
    
    @Override
    public void eat() {
        System.out.println(getName() + "이(가) 생선을 조심스럽게 먹습니다.");
    }
}

// 새로운 자식 클래스 추가
class Bird extends Animal {
    public Bird(String name) {
        super(name);
    }
    
    @Override
    public void makeSound() {
        System.out.println(getName() + ": 짹짹!");
    }
    
    @Override
    protected void wakeUp() {
        System.out.println(getName() + "이(가) 날아다니며 일어났습니다.");
    }
    
    // 새로 추가된 메소드
    public void fly() {
        System.out.println(getName() + "이(가) 하늘을 날아갑니다.");
    }
}

// 메인 클래스
public class AbstractAnimalTest {
    public static void main(String[] args) {
        // 추상 클래스는 인스턴스화 불가
        // Animal animal = new Animal("동물"); // 컴파일 오류!
        
        Animal[] animals = {
            new Dog("뽀삐"),
            new Cat("나비"),
            new Bird("참새")
        };
        
        // 다형성 활용
        for (Animal animal : animals) {
            animal.dailyRoutine();
            
            // 타입 체크로 특정 기능 호출
            if (animal instanceof Bird) {
                ((Bird) animal).fly();
            }
        }
    }
}
```

## 예제 2: 도형 추상 클래스로 확장

```java
// 추상 부모 클래스
abstract class Shape {
    private String color;
    
    public Shape(String color) {
        this.color = color;
    }
    
    // 추상 메소드들 - 자식 클래스에서 반드시 구현
    public abstract double getArea();
    public abstract double getPerimeter();
    
    // 일반 메소드
    public void displayInfo() {
        System.out.println("도형 정보:");
        System.out.println("색상: " + color);
        System.out.println("넓이: " + getArea());
        System.out.println("둘레: " + getPerimeter());
        draw();
        System.out.println();
    }
    
    // 추상 메소드
    public abstract void draw();
    
    // final 메소드 - 오버라이딩 금지
    public final String getColor() {
        return color;
    }
}

// 추상 중간 클래스
abstract class Polygon extends Shape {
    private int sides;
    
    public Polygon(String color, int sides) {
        super(color);
        this.sides = sides;
    }
    
    public int getSides() {
        return sides;
    }
    
    @Override
    public void draw() {
        System.out.println(getSides() + "각형을 그립니다.");
    }
}

// 구체적인 자식 클래스들
class Circle extends Shape {
    private double radius;
    
    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
    
    @Override
    public void draw() {
        System.out.println(getColor() + "색 원을 그립니다. 반지름: " + radius);
    }
    
    // Circle 고유 메소드
    public double getDiameter() {
        return 2 * radius;
    }
}

class Rectangle extends Polygon {
    private double width;
    private double height;
    
    public Rectangle(String color, double width, double height) {
        super(color, 4); // 4각형
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
    
    @Override
    public void draw() {
        System.out.println(getColor() + "색 직사각형을 그립니다. " +
                         "너비: " + width + ", 높이: " + height);
    }
}

class Triangle extends Polygon {
    private double base;
    private double height;
    private double side1;
    private double side2;
    
    public Triangle(String color, double base, double height, double side1, double side2) {
        super(color, 3); // 3각형
        this.base = base;
        this.height = height;
        this.side1 = side1;
        this.side2 = side2;
    }
    
    @Override
    public double getArea() {
        return (base * height) / 2;
    }
    
    @Override
    public double getPerimeter() {
        return base + side1 + side2;
    }
    
    @Override
    public void draw() {
        System.out.println(getColor() + "색 삼각형을 그립니다. " +
                         "밑변: " + base + ", 높이: " + height);
    }
}

// 메인 클래스
public class AbstractShapeTest {
    public static void main(String[] args) {
        Shape[] shapes = {
            new Circle("빨강", 5.0),
            new Rectangle("파랑", 4.0, 6.0),
            new Triangle("초록", 3.0, 4.0, 5.0, 4.0)
        };
        
        for (Shape shape : shapes) {
            shape.displayInfo();
            
            // 추가 정보 출력
            if (shape instanceof Polygon) {
                System.out.println("변의 개수: " + ((Polygon) shape).getSides());
            }
            if (shape instanceof Circle) {
                System.out.println("지름: " + ((Circle) shape).getDiameter());
            }
            System.out.println("----------------------");
        }
    }
}
```

## 예제 3: 직원 관리 시스템 추상 클래스로 확장

```java
// 추상 부모 클래스
abstract class Employee {
    private String name;
    private int employeeId;
    private double baseSalary;
    
    public Employee(String name, int employeeId, double baseSalary) {
        this.name = name;
        this.employeeId = employeeId;
        this.baseSalary = baseSalary;
    }
    
    // 추상 메소드 - 모든 직원은 업무 수행 방법이 다름
    public abstract void performDuties();
    
    // 추상 메소드 - 보너스 계산 방식이 직급마다 다름
    protected abstract double calculateBonus();
    
    // 템플릿 메소드 - 전체 급여 계산 알고리즘 정의
    public final double calculateSalary() {
        double bonus = calculateBonus();
        double deductions = calculateDeductions();
        return baseSalary + bonus - deductions;
    }
    
    // 후크 메소드 - 기본 구현 제공, 필요시 오버라이드
    protected double calculateDeductions() {
        // 기본 공제액: 기본급의 10%
        return baseSalary * 0.1;
    }
    
    // 일반 메소드
    public void displayInfo() {
        System.out.println("=== 직원 정보 ===");
        System.out.println("이름: " + name);
        System.out.println("사원번호: " + employeeId);
        System.out.println("직급: " + getPosition());
        System.out.println("기본급: " + baseSalary + "원");
        System.out.println("실수령액: " + calculateSalary() + "원");
        performDuties();
        System.out.println();
    }
    
    // 추상 메소드
    public abstract String getPosition();
    
    // Getter 메소드들
    public String getName() {
        return name;
    }
    
    public int getEmployeeId() {
        return employeeId;
    }
    
    public double getBaseSalary() {
        return baseSalary;
    }
}

// 구체적인 직원 클래스들
class Manager extends Employee {
    private double performanceBonus;
    
    public Manager(String name, int employeeId, double baseSalary, double performanceBonus) {
        super(name, employeeId, baseSalary);
        this.performanceBonus = performanceBonus;
    }
    
    @Override
    public void performDuties() {
        System.out.println("팀 관리 및 프로젝트 계획 수립을 수행합니다.");
        conductMeeting();
    }
    
    @Override
    protected double calculateBonus() {
        // 관리자 보너스: 성과 보너스 + 기본급의 20%
        return performanceBonus + (getBaseSalary() * 0.2);
    }
    
    @Override
    public String getPosition() {
        return "매니저";
    }
    
    @Override
    protected double calculateDeductions() {
        // 관리자는 추가 세금 공제
        return super.calculateDeductions() + (getBaseSalary() * 0.05);
    }
    
    public void conductMeeting() {
        System.out.println(getName() + " 매니저가 회의를 주관합니다.");
    }
}

class Developer extends Employee {
    private String programmingLanguage;
    private int completedProjects;
    
    public Developer(String name, int employeeId, double baseSalary, 
                     String programmingLanguage, int completedProjects) {
        super(name, employeeId, baseSalary);
        this.programmingLanguage = programmingLanguage;
        this.completedProjects = completedProjects;
    }
    
    @Override
    public void performDuties() {
        System.out.println(programmingLanguage + " 언어로 소프트웨어 개발을 수행합니다.");
        debugCode();
    }
    
    @Override
    protected double calculateBonus() {
        // 개발자 보너스: 완료 프로젝트당 10만원
        return completedProjects * 100000;
    }
    
    @Override
    public String getPosition() {
        return "개발자";
    }
    
    public void debugCode() {
        System.out.println(getName() + " 개발자가 코드 디버깅을 합니다.");
    }
}

class Intern extends Employee {
    private String university;
    private int internshipMonths;
    
    public Intern(String name, int employeeId, double baseSalary, 
                  String university, int internshipMonths) {
        super(name, employeeId, baseSalary);
        this.university = university;
        this.internshipMonths = internshipMonths;
    }
    
    @Override
    public void performDuties() {
        System.out.println("업무 보조 및 학습을 수행합니다.");
        attendTraining();
    }
    
    @Override
    protected double calculateBonus() {
        // 인턴은 보너스 없음
        return 0;
    }
    
    @Override
    public String getPosition() {
        return "인턴";
    }
    
    @Override
    protected double calculateDeductions() {
        // 인턴은 공제액이 적음
        return getBaseSalary() * 0.05;
    }
    
    public void attendTraining() {
        System.out.println(getName() + " 인턴이 교육에 참여합니다. (" + university + " 출신)");
    }
}

// 메인 클래스
public class AbstractEmployeeTest {
    public static void main(String[] args) {
        Employee[] employees = {
            new Manager("김철수", 1001, 5000000, 1000000),
            new Developer("이영희", 1002, 4000000, "Java", 3),
            new Intern("박지민", 1003, 2000000, "서울대학교", 6)
        };
        
        // 각 직원 정보 출력
        for (Employee emp : employees) {
            emp.displayInfo();
            
            // 직급별 추가 정보
            if (emp instanceof Intern) {
                System.out.println("인턴십 기간: " + ((Intern) emp).internshipMonths + "개월");
            }
            System.out.println("======================");
        }
        
        // 급여 총액 계산
        double totalSalary = 0;
        for (Employee emp : employees) {
            totalSalary += emp.calculateSalary();
        }
        System.out.println("전체 직원 급여 총액: " + totalSalary + "원");
    }
}
```

## 추상 클래스의 주요 특징

### 1. **추상 메소드 (Abstract Method)**
- `abstract` 키워드로 선언
- 구현부 없이 선언만 존재
- 자식 클래스에서 반드시 구현해야 함

### 2. **추상 클래스 (Abstract Class)**
- `abstract` 키워드로 선언
- 인스턴스화 불가 (`new` 연산자 사용 불가)
- 추상 메소드와 일반 메소드 모두 가질 수 있음

### 3. **템플릿 메소드 패턴 (Template Method Pattern)**
- 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에서 구현
- `final` 메소드로 알고리즘 구조 고정

### 4. **후크 메소드 (Hook Method)**
- 기본 구현을 제공하지만 서브클래스에서 오버라이드 가능
- 선택적인 확장 지점 제공

### 5. **추상 클래스 vs 인터페이스**
- 추상 클래스: 상태(필드)와 행동(메소드) 모두 정의 가능, 단일 상속
- 인터페이스: 행동만 정의, 다중 구현 가능

이러한 추상 클래스를 사용하면:
1. **공통 기능의 재사용성 증가**
2. **코드의 일관성 유지**
3. **강제적인 구현 보장**
4. **유연한 확장성 제공**
