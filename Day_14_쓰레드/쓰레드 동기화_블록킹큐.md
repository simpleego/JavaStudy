# BlockingQueue(블록킹)

---

## 🧩 BlockingQueue 활용 사례

### 1. **웹 서버의 요청 처리**
- **상황**: 웹 서버는 동시에 수많은 클라이언트 요청을 받음.  
- **문제점**: 요청을 즉시 처리할 수 없으면 서버가 과부하에 걸림.  
- **해결책**:  
  - 요청을 **BlockingQueue**에 저장.  
  - 워커 쓰레드(Worker Thread)가 큐에서 요청을 꺼내 순차적으로 처리.  
  - 큐가 가득 차면 새로운 요청은 대기 → 서버 안정성 확보.  

**흐름 예시**  
1. 클라이언트 요청 → 큐에 `put()`  
2. 워커 쓰레드 → 큐에서 `take()` → 요청 처리  
3. 큐가 비면 워커 쓰레드는 대기 상태로 전환  

---

### 2. **스레드 풀(Thread Pool) 구현**
- **상황**: 대규모 작업을 동시에 처리해야 할 때, 매번 쓰레드를 생성하면 비용이 큼.  
- **문제점**: 쓰레드 생성/소멸 오버헤드, 자원 낭비.  
- **해결책**:  
  - **BlockingQueue**를 작업 큐(Task Queue)로 사용.  
  - 스레드 풀의 워커 쓰레드들이 큐에서 작업을 꺼내 실행.  
  - 작업이 없으면 워커 쓰레드는 대기, 작업이 들어오면 즉시 처리.  

**흐름 예시**  
1. 작업 제출 → 큐에 `put()`  
2. 워커 쓰레드 → 큐에서 `take()` → 작업 실행  
3. 스레드 풀은 일정 개수의 쓰레드만 유지 → 자원 효율적 사용  

---

### 3. **실무에서 BlockingQueue를 활용하는 대표적 예**
- **로그 처리 시스템**: 애플리케이션 로그를 큐에 넣고, 별도 쓰레드가 파일/DB에 기록.  
- **메시지 큐 시스템**: 이벤트 기반 아키텍처에서 메시지를 큐에 저장하고 소비자가 처리.  
- **비동기 작업 처리**: 이메일 전송, 이미지 변환 같은 시간이 오래 걸리는 작업을 큐에 넣고 백그라운드에서 처리.  

---

## 💻 간단한 스레드 풀 예제

```java
import java.util.concurrent.*;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 작업 큐 (BlockingQueue)
        BlockingQueue<Runnable> taskQueue = new LinkedBlockingQueue<>();

        // 스레드 풀 생성 (3개의 워커 쓰레드)
        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                while (true) {
                    try {
                        Runnable task = taskQueue.take(); // 작업 대기
                        task.run(); // 작업 실행
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        break;
                    }
                }
            }).start();
        }

        // 작업 제출
        for (int i = 1; i <= 5; i++) {
            int jobId = i;
            taskQueue.add(() -> {
                System.out.println("작업 " + jobId + " 실행 중 (쓰레드: " + Thread.currentThread().getName() + ")");
                try {
                    Thread.sleep(1000); // 작업 처리 시간
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }
    }
}
```

---

## ⚡ 실행 결과 예시
```
작업 1 실행 중 (쓰레드: Thread-0)
작업 2 실행 중 (쓰레드: Thread-1)
작업 3 실행 중 (쓰레드: Thread-2)
작업 4 실행 중 (쓰레드: Thread-0)
작업 5 실행 중 (쓰레드: Thread-1)
```

---

## ✅ 핵심 포인트
- **BlockingQueue**는 생산자-소비자 패턴의 핵심 도구.  
- **웹 서버 요청 처리**와 **스레드 풀 구현**에서 안정성과 효율성을 보장.  
- 실무에서는 **로그 처리, 이벤트 큐, 비동기 작업 처리** 등 다양한 곳에서 활용됨.  

---
