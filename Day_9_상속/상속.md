# 상속
> 상속은 현실세계에 존재하는 객체를 계층화(상하관계와 종류별로)할 수 있는 기능으로 사용하면 된다.
> 추가적으로 각각의 계층적 객체가 갖는 기능을 재사용할 수 도 있다.

---

# 🚀 1. 상속(Inheritance)의 핵심 목적: **계층화(Hierarchy)**

상속은 “코드를 줄이기 위해 쓰는 기술”이 아니라  
**현실 세계의 구조를 그대로 코드로 표현하기 위한 도구**야.

예를 들어:

```
탈것(Vehicle)
   └── 자동차(Car)
         ├── 전기차(ElectricCar)
         ├── 스포츠카(SportsCar)
         └── 버스(Bus)
```

이런 구조는 현실 세계의 분류 체계를 그대로 반영한 것.  
→ **상속의 목적 = 계층화 = 분류 체계 만들기**

---

# 🚗 2. 1단계: 기본 상속 구조 만들기 (Vehicle → Car)

## 📌 Vehicle.java (부모 클래스)

```java
public class Vehicle {
    protected String brand;
    protected int speed;

    public Vehicle(String brand) {
        this.brand = brand;
        this.speed = 0;
    }

    public void start() {
        System.out.println(brand + " 시동 켭니다.");
    }

    public void stop() {
        speed = 0;
        System.out.println(brand + " 정지합니다.");
    }

    public void accelerate(int amount) {
        speed += amount;
        System.out.println(brand + " 속도: " + speed + "km/h");
    }
}
```

---

## 📌 Car.java (Vehicle을 상속)

```java
public class Car extends Vehicle {
    protected int wheelCount;

    public Car(String brand, int wheelCount) {
        super(brand); // 부모 생성자 호출
        this.wheelCount = wheelCount;
    }

    public void honk() {
        System.out.println(brand + " 빵빵!");
    }
}
```

---

# 🧱 3. 2단계: 계층 확장 (Car → 세부 자동차)

## 📌 SportsCar.java

```java
public class SportsCar extends Car {
    public SportsCar(String brand) {
        super(brand, 4);
    }

    @Override
    public void accelerate(int amount) {
        super.accelerate(amount * 2); // 스포츠카는 더 빠르게 가속
    }
}
```

### ✔ 오버라이딩(Overriding) 포인트
- 부모의 accelerate()를 재정의
- “스포츠카는 더 빠르게 가속한다”라는 **현실 세계의 특성 반영**

---

## 📌 ElectricCar.java

```java
public class ElectricCar extends Car {
    private int battery;

    public ElectricCar(String brand, int battery) {
        super(brand, 4);
        this.battery = battery;
    }

    public void charge() {
        battery = 100;
        System.out.println(brand + " 배터리 충전 완료!");
    }
}
```

---

# 🎭 4. 3단계: 다형성(Polymorphism)

다형성은 “부모 타입으로 자식 객체를 다루는 것”.

## ✔ 업캐스팅(Upcasting)
자식 → 부모로 자동 변환

```java
Car car1 = new SportsCar("Ferrari");   // 업캐스팅
Car car2 = new ElectricCar("Tesla", 80);
```

### 업캐스팅의 의미
- “자동차(Car)라는 공통된 관점으로 바라본다”
- 계층화의 핵심 효과

---

## ✔ 다형성의 핵심: 오버라이딩된 메서드 호출

```java
car1.accelerate(10);  // SportsCar의 accelerate() 실행
    -> 이유는 상속하는 클래스가 상위 클래스의 메서드를 재정의 하지 않으면
       상위 클래스에서 정의된 메서드를 사용하게 된다.
       따라서 상위 클래스에 정의된 메서드가 맘에 들지 않으면
       고쳐서(재정의 override) 사용해야 된다.
car2.accelerate(10);  // Vehicle의 accelerate() 실행
  -> 이 객체의 경우에는 해당 클래스에서 Car 클래스가 Vehicle 클래스의 모든 기능을
     사용가능하지만 상위 클래스의 accelerate() 메서드를 재정의 하지 않아서
     자신만의 accelerate() 기능이 아닌 상속받은 기능을 그대로 사용하게 된다.
     그러나 일반적으로 자신만의 기능을 위해서 재정의를 이용하여 고쳐서 사용한다. 
```

→ **부모 타입으로 호출해도 실제 객체의 메서드가 실행됨**

---

## ✔ 다운캐스팅(Downcasting)
부모 → 자식으로 강제 변환  
특정 기능을 사용하고 싶을 때 필요

```java
Car car = new ElectricCar("Tesla", 80);

// 다운캐스팅
ElectricCar ec = (ElectricCar) car;
ec.charge();
```

### 다운캐스팅 시 주의
- 반드시 실제 객체 타입을 확인해야 함

```java
if (car instanceof ElectricCar) {
    ((ElectricCar) car).charge();
}
```

---

# 🧪 5. 전체 테스트 코드 (업/다운캐스팅 + 다형성)

```java
public class Main {
    public static void main(String[] args) {

        Car[] cars = {
            new SportsCar("Ferrari"),
            new ElectricCar("Tesla", 80)
        };

        for (Car c : cars) {
            c.start();
            c.accelerate(20);  // 다형성: 각 클래스의 accelerate() 실행
            c.honk();

            // 다운캐스팅 예제
            if (c instanceof ElectricCar) {
                ((ElectricCar) c).charge();
            }

            System.out.println();
        }
    }
}
```

---

# 🧩 6. 상속 + 계층화 + 오버라이딩 + 다형성 요약

| 개념 | 설명 | 예제 |
|------|------|------|
| **상속** | 계층 구조를 만들기 위한 도구 | Vehicle → Car → SportsCar |
| **계층화** | 현실 세계의 분류 체계를 코드로 표현 | 탈것 → 자동차 → 전기차 |
| **오버라이딩** | 자식이 부모의 기능을 재정의 | SportsCar.accelerate() |
| **업캐스팅** | 자식을 부모 타입으로 | Car car = new SportsCar() |
| **다형성** | 부모 타입으로 자식을 다루고, 자식 메서드 실행 | car.accelerate() |
| **다운캐스팅** | 부모 → 자식으로 변환 | ((ElectricCar)car).charge() |

---

# 🎓 7. 강의용 핵심 메시지

### ✔ 상속의 목적은 “코드 재사용”이 아니라 **계층화**
- 현실 세계의 구조를 그대로 코드로 표현하는 것  
- 공통 기능은 위로, 특화 기능은 아래로

### ✔ 오버라이딩은 “자식의 개성 표현”
- 부모의 기능을 자식이 재정의  
- 다형성의 핵심 기반

### ✔ 업캐스팅은 “공통된 관점으로 보기”
- Car 타입으로 모든 자동차를 다룰 수 있음

### ✔ 다운캐스팅은 “특정 기능을 쓰고 싶을 때”
- ElectricCar만의 charge() 같은 기능

---

수업용 PPT 형태 요약**

어떤 방향으로 더 확장해줄까?
